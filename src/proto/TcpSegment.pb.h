// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TcpSegment.proto

#ifndef PROTOBUF_TcpSegment_2eproto__INCLUDED
#define PROTOBUF_TcpSegment_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace TcpSegment {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_TcpSegment_2eproto();
void protobuf_AssignDesc_TcpSegment_2eproto();
void protobuf_ShutdownFile_TcpSegment_2eproto();

class TcpSegmentHeader;
class TcpSegment;

// ===================================================================

class TcpSegmentHeader : public ::google::protobuf::Message {
 public:
  TcpSegmentHeader();
  virtual ~TcpSegmentHeader();

  TcpSegmentHeader(const TcpSegmentHeader& from);

  inline TcpSegmentHeader& operator=(const TcpSegmentHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TcpSegmentHeader& default_instance();

  void Swap(TcpSegmentHeader* other);

  // implements Message ----------------------------------------------

  TcpSegmentHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TcpSegmentHeader& from);
  void MergeFrom(const TcpSegmentHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 source_port = 1;
  inline bool has_source_port() const;
  inline void clear_source_port();
  static const int kSourcePortFieldNumber = 1;
  inline ::google::protobuf::uint32 source_port() const;
  inline void set_source_port(::google::protobuf::uint32 value);

  // required uint32 dest_port = 2;
  inline bool has_dest_port() const;
  inline void clear_dest_port();
  static const int kDestPortFieldNumber = 2;
  inline ::google::protobuf::uint32 dest_port() const;
  inline void set_dest_port(::google::protobuf::uint32 value);

  // required uint32 seq_num = 3;
  inline bool has_seq_num() const;
  inline void clear_seq_num();
  static const int kSeqNumFieldNumber = 3;
  inline ::google::protobuf::uint32 seq_num() const;
  inline void set_seq_num(::google::protobuf::uint32 value);

  // required uint32 ack_num = 4;
  inline bool has_ack_num() const;
  inline void clear_ack_num();
  static const int kAckNumFieldNumber = 4;
  inline ::google::protobuf::uint32 ack_num() const;
  inline void set_ack_num(::google::protobuf::uint32 value);

  // required uint32 offset = 5;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 5;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);

  // required uint32 keep_bits = 6;
  inline bool has_keep_bits() const;
  inline void clear_keep_bits();
  static const int kKeepBitsFieldNumber = 6;
  inline ::google::protobuf::uint32 keep_bits() const;
  inline void set_keep_bits(::google::protobuf::uint32 value);

  // required bool URG_bit = 7;
  inline bool has_urg_bit() const;
  inline void clear_urg_bit();
  static const int kURGBitFieldNumber = 7;
  inline bool urg_bit() const;
  inline void set_urg_bit(bool value);

  // required bool ACK_bit = 8;
  inline bool has_ack_bit() const;
  inline void clear_ack_bit();
  static const int kACKBitFieldNumber = 8;
  inline bool ack_bit() const;
  inline void set_ack_bit(bool value);

  // required bool PSH_bit = 9;
  inline bool has_psh_bit() const;
  inline void clear_psh_bit();
  static const int kPSHBitFieldNumber = 9;
  inline bool psh_bit() const;
  inline void set_psh_bit(bool value);

  // required bool RST_bit = 10;
  inline bool has_rst_bit() const;
  inline void clear_rst_bit();
  static const int kRSTBitFieldNumber = 10;
  inline bool rst_bit() const;
  inline void set_rst_bit(bool value);

  // required bool SYN_bit = 11;
  inline bool has_syn_bit() const;
  inline void clear_syn_bit();
  static const int kSYNBitFieldNumber = 11;
  inline bool syn_bit() const;
  inline void set_syn_bit(bool value);

  // required bool FIN_bit = 12;
  inline bool has_fin_bit() const;
  inline void clear_fin_bit();
  static const int kFINBitFieldNumber = 12;
  inline bool fin_bit() const;
  inline void set_fin_bit(bool value);

  // required uint32 window_size = 13;
  inline bool has_window_size() const;
  inline void clear_window_size();
  static const int kWindowSizeFieldNumber = 13;
  inline ::google::protobuf::uint32 window_size() const;
  inline void set_window_size(::google::protobuf::uint32 value);

  // required uint32 check_sum = 14;
  inline bool has_check_sum() const;
  inline void clear_check_sum();
  static const int kCheckSumFieldNumber = 14;
  inline ::google::protobuf::uint32 check_sum() const;
  inline void set_check_sum(::google::protobuf::uint32 value);

  // required uint32 URG_pointer = 15;
  inline bool has_urg_pointer() const;
  inline void clear_urg_pointer();
  static const int kURGPointerFieldNumber = 15;
  inline ::google::protobuf::uint32 urg_pointer() const;
  inline void set_urg_pointer(::google::protobuf::uint32 value);

  // optional string Options = 16;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 16;
  inline const ::std::string& options() const;
  inline void set_options(const ::std::string& value);
  inline void set_options(const char* value);
  inline void set_options(const char* value, size_t size);
  inline ::std::string* mutable_options();
  inline ::std::string* release_options();
  inline void set_allocated_options(::std::string* options);

  // @@protoc_insertion_point(class_scope:TcpSegment.TcpSegmentHeader)
 private:
  inline void set_has_source_port();
  inline void clear_has_source_port();
  inline void set_has_dest_port();
  inline void clear_has_dest_port();
  inline void set_has_seq_num();
  inline void clear_has_seq_num();
  inline void set_has_ack_num();
  inline void clear_has_ack_num();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_keep_bits();
  inline void clear_has_keep_bits();
  inline void set_has_urg_bit();
  inline void clear_has_urg_bit();
  inline void set_has_ack_bit();
  inline void clear_has_ack_bit();
  inline void set_has_psh_bit();
  inline void clear_has_psh_bit();
  inline void set_has_rst_bit();
  inline void clear_has_rst_bit();
  inline void set_has_syn_bit();
  inline void clear_has_syn_bit();
  inline void set_has_fin_bit();
  inline void clear_has_fin_bit();
  inline void set_has_window_size();
  inline void clear_has_window_size();
  inline void set_has_check_sum();
  inline void clear_has_check_sum();
  inline void set_has_urg_pointer();
  inline void clear_has_urg_pointer();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 source_port_;
  ::google::protobuf::uint32 dest_port_;
  ::google::protobuf::uint32 seq_num_;
  ::google::protobuf::uint32 ack_num_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 keep_bits_;
  bool urg_bit_;
  bool ack_bit_;
  bool psh_bit_;
  bool rst_bit_;
  bool syn_bit_;
  bool fin_bit_;
  ::google::protobuf::uint32 window_size_;
  ::google::protobuf::uint32 check_sum_;
  ::std::string* options_;
  ::google::protobuf::uint32 urg_pointer_;
  friend void  protobuf_AddDesc_TcpSegment_2eproto();
  friend void protobuf_AssignDesc_TcpSegment_2eproto();
  friend void protobuf_ShutdownFile_TcpSegment_2eproto();

  void InitAsDefaultInstance();
  static TcpSegmentHeader* default_instance_;
};
// -------------------------------------------------------------------

class TcpSegment : public ::google::protobuf::Message {
 public:
  TcpSegment();
  virtual ~TcpSegment();

  TcpSegment(const TcpSegment& from);

  inline TcpSegment& operator=(const TcpSegment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TcpSegment& default_instance();

  void Swap(TcpSegment* other);

  // implements Message ----------------------------------------------

  TcpSegment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TcpSegment& from);
  void MergeFrom(const TcpSegment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .TcpSegment.TcpSegmentHeader TcpHeader = 1;
  inline bool has_tcpheader() const;
  inline void clear_tcpheader();
  static const int kTcpHeaderFieldNumber = 1;
  inline const ::TcpSegment::TcpSegmentHeader& tcpheader() const;
  inline ::TcpSegment::TcpSegmentHeader* mutable_tcpheader();
  inline ::TcpSegment::TcpSegmentHeader* release_tcpheader();
  inline void set_allocated_tcpheader(::TcpSegment::TcpSegmentHeader* tcpheader);

  // required string TcpData = 2;
  inline bool has_tcpdata() const;
  inline void clear_tcpdata();
  static const int kTcpDataFieldNumber = 2;
  inline const ::std::string& tcpdata() const;
  inline void set_tcpdata(const ::std::string& value);
  inline void set_tcpdata(const char* value);
  inline void set_tcpdata(const char* value, size_t size);
  inline ::std::string* mutable_tcpdata();
  inline ::std::string* release_tcpdata();
  inline void set_allocated_tcpdata(::std::string* tcpdata);

  // @@protoc_insertion_point(class_scope:TcpSegment.TcpSegment)
 private:
  inline void set_has_tcpheader();
  inline void clear_has_tcpheader();
  inline void set_has_tcpdata();
  inline void clear_has_tcpdata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::TcpSegment::TcpSegmentHeader* tcpheader_;
  ::std::string* tcpdata_;
  friend void  protobuf_AddDesc_TcpSegment_2eproto();
  friend void protobuf_AssignDesc_TcpSegment_2eproto();
  friend void protobuf_ShutdownFile_TcpSegment_2eproto();

  void InitAsDefaultInstance();
  static TcpSegment* default_instance_;
};
// ===================================================================


// ===================================================================

// TcpSegmentHeader

// required uint32 source_port = 1;
inline bool TcpSegmentHeader::has_source_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TcpSegmentHeader::set_has_source_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TcpSegmentHeader::clear_has_source_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TcpSegmentHeader::clear_source_port() {
  source_port_ = 0u;
  clear_has_source_port();
}
inline ::google::protobuf::uint32 TcpSegmentHeader::source_port() const {
  // @@protoc_insertion_point(field_get:TcpSegment.TcpSegmentHeader.source_port)
  return source_port_;
}
inline void TcpSegmentHeader::set_source_port(::google::protobuf::uint32 value) {
  set_has_source_port();
  source_port_ = value;
  // @@protoc_insertion_point(field_set:TcpSegment.TcpSegmentHeader.source_port)
}

// required uint32 dest_port = 2;
inline bool TcpSegmentHeader::has_dest_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TcpSegmentHeader::set_has_dest_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TcpSegmentHeader::clear_has_dest_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TcpSegmentHeader::clear_dest_port() {
  dest_port_ = 0u;
  clear_has_dest_port();
}
inline ::google::protobuf::uint32 TcpSegmentHeader::dest_port() const {
  // @@protoc_insertion_point(field_get:TcpSegment.TcpSegmentHeader.dest_port)
  return dest_port_;
}
inline void TcpSegmentHeader::set_dest_port(::google::protobuf::uint32 value) {
  set_has_dest_port();
  dest_port_ = value;
  // @@protoc_insertion_point(field_set:TcpSegment.TcpSegmentHeader.dest_port)
}

// required uint32 seq_num = 3;
inline bool TcpSegmentHeader::has_seq_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TcpSegmentHeader::set_has_seq_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TcpSegmentHeader::clear_has_seq_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TcpSegmentHeader::clear_seq_num() {
  seq_num_ = 0u;
  clear_has_seq_num();
}
inline ::google::protobuf::uint32 TcpSegmentHeader::seq_num() const {
  // @@protoc_insertion_point(field_get:TcpSegment.TcpSegmentHeader.seq_num)
  return seq_num_;
}
inline void TcpSegmentHeader::set_seq_num(::google::protobuf::uint32 value) {
  set_has_seq_num();
  seq_num_ = value;
  // @@protoc_insertion_point(field_set:TcpSegment.TcpSegmentHeader.seq_num)
}

// required uint32 ack_num = 4;
inline bool TcpSegmentHeader::has_ack_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TcpSegmentHeader::set_has_ack_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TcpSegmentHeader::clear_has_ack_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TcpSegmentHeader::clear_ack_num() {
  ack_num_ = 0u;
  clear_has_ack_num();
}
inline ::google::protobuf::uint32 TcpSegmentHeader::ack_num() const {
  // @@protoc_insertion_point(field_get:TcpSegment.TcpSegmentHeader.ack_num)
  return ack_num_;
}
inline void TcpSegmentHeader::set_ack_num(::google::protobuf::uint32 value) {
  set_has_ack_num();
  ack_num_ = value;
  // @@protoc_insertion_point(field_set:TcpSegment.TcpSegmentHeader.ack_num)
}

// required uint32 offset = 5;
inline bool TcpSegmentHeader::has_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TcpSegmentHeader::set_has_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TcpSegmentHeader::clear_has_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TcpSegmentHeader::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 TcpSegmentHeader::offset() const {
  // @@protoc_insertion_point(field_get:TcpSegment.TcpSegmentHeader.offset)
  return offset_;
}
inline void TcpSegmentHeader::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:TcpSegment.TcpSegmentHeader.offset)
}

// required uint32 keep_bits = 6;
inline bool TcpSegmentHeader::has_keep_bits() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TcpSegmentHeader::set_has_keep_bits() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TcpSegmentHeader::clear_has_keep_bits() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TcpSegmentHeader::clear_keep_bits() {
  keep_bits_ = 0u;
  clear_has_keep_bits();
}
inline ::google::protobuf::uint32 TcpSegmentHeader::keep_bits() const {
  // @@protoc_insertion_point(field_get:TcpSegment.TcpSegmentHeader.keep_bits)
  return keep_bits_;
}
inline void TcpSegmentHeader::set_keep_bits(::google::protobuf::uint32 value) {
  set_has_keep_bits();
  keep_bits_ = value;
  // @@protoc_insertion_point(field_set:TcpSegment.TcpSegmentHeader.keep_bits)
}

// required bool URG_bit = 7;
inline bool TcpSegmentHeader::has_urg_bit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TcpSegmentHeader::set_has_urg_bit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TcpSegmentHeader::clear_has_urg_bit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TcpSegmentHeader::clear_urg_bit() {
  urg_bit_ = false;
  clear_has_urg_bit();
}
inline bool TcpSegmentHeader::urg_bit() const {
  // @@protoc_insertion_point(field_get:TcpSegment.TcpSegmentHeader.URG_bit)
  return urg_bit_;
}
inline void TcpSegmentHeader::set_urg_bit(bool value) {
  set_has_urg_bit();
  urg_bit_ = value;
  // @@protoc_insertion_point(field_set:TcpSegment.TcpSegmentHeader.URG_bit)
}

// required bool ACK_bit = 8;
inline bool TcpSegmentHeader::has_ack_bit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TcpSegmentHeader::set_has_ack_bit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TcpSegmentHeader::clear_has_ack_bit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TcpSegmentHeader::clear_ack_bit() {
  ack_bit_ = false;
  clear_has_ack_bit();
}
inline bool TcpSegmentHeader::ack_bit() const {
  // @@protoc_insertion_point(field_get:TcpSegment.TcpSegmentHeader.ACK_bit)
  return ack_bit_;
}
inline void TcpSegmentHeader::set_ack_bit(bool value) {
  set_has_ack_bit();
  ack_bit_ = value;
  // @@protoc_insertion_point(field_set:TcpSegment.TcpSegmentHeader.ACK_bit)
}

// required bool PSH_bit = 9;
inline bool TcpSegmentHeader::has_psh_bit() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TcpSegmentHeader::set_has_psh_bit() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TcpSegmentHeader::clear_has_psh_bit() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TcpSegmentHeader::clear_psh_bit() {
  psh_bit_ = false;
  clear_has_psh_bit();
}
inline bool TcpSegmentHeader::psh_bit() const {
  // @@protoc_insertion_point(field_get:TcpSegment.TcpSegmentHeader.PSH_bit)
  return psh_bit_;
}
inline void TcpSegmentHeader::set_psh_bit(bool value) {
  set_has_psh_bit();
  psh_bit_ = value;
  // @@protoc_insertion_point(field_set:TcpSegment.TcpSegmentHeader.PSH_bit)
}

// required bool RST_bit = 10;
inline bool TcpSegmentHeader::has_rst_bit() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TcpSegmentHeader::set_has_rst_bit() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TcpSegmentHeader::clear_has_rst_bit() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TcpSegmentHeader::clear_rst_bit() {
  rst_bit_ = false;
  clear_has_rst_bit();
}
inline bool TcpSegmentHeader::rst_bit() const {
  // @@protoc_insertion_point(field_get:TcpSegment.TcpSegmentHeader.RST_bit)
  return rst_bit_;
}
inline void TcpSegmentHeader::set_rst_bit(bool value) {
  set_has_rst_bit();
  rst_bit_ = value;
  // @@protoc_insertion_point(field_set:TcpSegment.TcpSegmentHeader.RST_bit)
}

// required bool SYN_bit = 11;
inline bool TcpSegmentHeader::has_syn_bit() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TcpSegmentHeader::set_has_syn_bit() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TcpSegmentHeader::clear_has_syn_bit() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TcpSegmentHeader::clear_syn_bit() {
  syn_bit_ = false;
  clear_has_syn_bit();
}
inline bool TcpSegmentHeader::syn_bit() const {
  // @@protoc_insertion_point(field_get:TcpSegment.TcpSegmentHeader.SYN_bit)
  return syn_bit_;
}
inline void TcpSegmentHeader::set_syn_bit(bool value) {
  set_has_syn_bit();
  syn_bit_ = value;
  // @@protoc_insertion_point(field_set:TcpSegment.TcpSegmentHeader.SYN_bit)
}

// required bool FIN_bit = 12;
inline bool TcpSegmentHeader::has_fin_bit() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TcpSegmentHeader::set_has_fin_bit() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TcpSegmentHeader::clear_has_fin_bit() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TcpSegmentHeader::clear_fin_bit() {
  fin_bit_ = false;
  clear_has_fin_bit();
}
inline bool TcpSegmentHeader::fin_bit() const {
  // @@protoc_insertion_point(field_get:TcpSegment.TcpSegmentHeader.FIN_bit)
  return fin_bit_;
}
inline void TcpSegmentHeader::set_fin_bit(bool value) {
  set_has_fin_bit();
  fin_bit_ = value;
  // @@protoc_insertion_point(field_set:TcpSegment.TcpSegmentHeader.FIN_bit)
}

// required uint32 window_size = 13;
inline bool TcpSegmentHeader::has_window_size() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TcpSegmentHeader::set_has_window_size() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TcpSegmentHeader::clear_has_window_size() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TcpSegmentHeader::clear_window_size() {
  window_size_ = 0u;
  clear_has_window_size();
}
inline ::google::protobuf::uint32 TcpSegmentHeader::window_size() const {
  // @@protoc_insertion_point(field_get:TcpSegment.TcpSegmentHeader.window_size)
  return window_size_;
}
inline void TcpSegmentHeader::set_window_size(::google::protobuf::uint32 value) {
  set_has_window_size();
  window_size_ = value;
  // @@protoc_insertion_point(field_set:TcpSegment.TcpSegmentHeader.window_size)
}

// required uint32 check_sum = 14;
inline bool TcpSegmentHeader::has_check_sum() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TcpSegmentHeader::set_has_check_sum() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TcpSegmentHeader::clear_has_check_sum() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TcpSegmentHeader::clear_check_sum() {
  check_sum_ = 0u;
  clear_has_check_sum();
}
inline ::google::protobuf::uint32 TcpSegmentHeader::check_sum() const {
  // @@protoc_insertion_point(field_get:TcpSegment.TcpSegmentHeader.check_sum)
  return check_sum_;
}
inline void TcpSegmentHeader::set_check_sum(::google::protobuf::uint32 value) {
  set_has_check_sum();
  check_sum_ = value;
  // @@protoc_insertion_point(field_set:TcpSegment.TcpSegmentHeader.check_sum)
}

// required uint32 URG_pointer = 15;
inline bool TcpSegmentHeader::has_urg_pointer() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TcpSegmentHeader::set_has_urg_pointer() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TcpSegmentHeader::clear_has_urg_pointer() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TcpSegmentHeader::clear_urg_pointer() {
  urg_pointer_ = 0u;
  clear_has_urg_pointer();
}
inline ::google::protobuf::uint32 TcpSegmentHeader::urg_pointer() const {
  // @@protoc_insertion_point(field_get:TcpSegment.TcpSegmentHeader.URG_pointer)
  return urg_pointer_;
}
inline void TcpSegmentHeader::set_urg_pointer(::google::protobuf::uint32 value) {
  set_has_urg_pointer();
  urg_pointer_ = value;
  // @@protoc_insertion_point(field_set:TcpSegment.TcpSegmentHeader.URG_pointer)
}

// optional string Options = 16;
inline bool TcpSegmentHeader::has_options() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TcpSegmentHeader::set_has_options() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TcpSegmentHeader::clear_has_options() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TcpSegmentHeader::clear_options() {
  if (options_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    options_->clear();
  }
  clear_has_options();
}
inline const ::std::string& TcpSegmentHeader::options() const {
  // @@protoc_insertion_point(field_get:TcpSegment.TcpSegmentHeader.Options)
  return *options_;
}
inline void TcpSegmentHeader::set_options(const ::std::string& value) {
  set_has_options();
  if (options_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    options_ = new ::std::string;
  }
  options_->assign(value);
  // @@protoc_insertion_point(field_set:TcpSegment.TcpSegmentHeader.Options)
}
inline void TcpSegmentHeader::set_options(const char* value) {
  set_has_options();
  if (options_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    options_ = new ::std::string;
  }
  options_->assign(value);
  // @@protoc_insertion_point(field_set_char:TcpSegment.TcpSegmentHeader.Options)
}
inline void TcpSegmentHeader::set_options(const char* value, size_t size) {
  set_has_options();
  if (options_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    options_ = new ::std::string;
  }
  options_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TcpSegment.TcpSegmentHeader.Options)
}
inline ::std::string* TcpSegmentHeader::mutable_options() {
  set_has_options();
  if (options_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    options_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TcpSegment.TcpSegmentHeader.Options)
  return options_;
}
inline ::std::string* TcpSegmentHeader::release_options() {
  clear_has_options();
  if (options_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = options_;
    options_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TcpSegmentHeader::set_allocated_options(::std::string* options) {
  if (options_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete options_;
  }
  if (options) {
    set_has_options();
    options_ = options;
  } else {
    clear_has_options();
    options_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TcpSegment.TcpSegmentHeader.Options)
}

// -------------------------------------------------------------------

// TcpSegment

// required .TcpSegment.TcpSegmentHeader TcpHeader = 1;
inline bool TcpSegment::has_tcpheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TcpSegment::set_has_tcpheader() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TcpSegment::clear_has_tcpheader() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TcpSegment::clear_tcpheader() {
  if (tcpheader_ != NULL) tcpheader_->::TcpSegment::TcpSegmentHeader::Clear();
  clear_has_tcpheader();
}
inline const ::TcpSegment::TcpSegmentHeader& TcpSegment::tcpheader() const {
  // @@protoc_insertion_point(field_get:TcpSegment.TcpSegment.TcpHeader)
  return tcpheader_ != NULL ? *tcpheader_ : *default_instance_->tcpheader_;
}
inline ::TcpSegment::TcpSegmentHeader* TcpSegment::mutable_tcpheader() {
  set_has_tcpheader();
  if (tcpheader_ == NULL) tcpheader_ = new ::TcpSegment::TcpSegmentHeader;
  // @@protoc_insertion_point(field_mutable:TcpSegment.TcpSegment.TcpHeader)
  return tcpheader_;
}
inline ::TcpSegment::TcpSegmentHeader* TcpSegment::release_tcpheader() {
  clear_has_tcpheader();
  ::TcpSegment::TcpSegmentHeader* temp = tcpheader_;
  tcpheader_ = NULL;
  return temp;
}
inline void TcpSegment::set_allocated_tcpheader(::TcpSegment::TcpSegmentHeader* tcpheader) {
  delete tcpheader_;
  tcpheader_ = tcpheader;
  if (tcpheader) {
    set_has_tcpheader();
  } else {
    clear_has_tcpheader();
  }
  // @@protoc_insertion_point(field_set_allocated:TcpSegment.TcpSegment.TcpHeader)
}

// required string TcpData = 2;
inline bool TcpSegment::has_tcpdata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TcpSegment::set_has_tcpdata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TcpSegment::clear_has_tcpdata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TcpSegment::clear_tcpdata() {
  if (tcpdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tcpdata_->clear();
  }
  clear_has_tcpdata();
}
inline const ::std::string& TcpSegment::tcpdata() const {
  // @@protoc_insertion_point(field_get:TcpSegment.TcpSegment.TcpData)
  return *tcpdata_;
}
inline void TcpSegment::set_tcpdata(const ::std::string& value) {
  set_has_tcpdata();
  if (tcpdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tcpdata_ = new ::std::string;
  }
  tcpdata_->assign(value);
  // @@protoc_insertion_point(field_set:TcpSegment.TcpSegment.TcpData)
}
inline void TcpSegment::set_tcpdata(const char* value) {
  set_has_tcpdata();
  if (tcpdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tcpdata_ = new ::std::string;
  }
  tcpdata_->assign(value);
  // @@protoc_insertion_point(field_set_char:TcpSegment.TcpSegment.TcpData)
}
inline void TcpSegment::set_tcpdata(const char* value, size_t size) {
  set_has_tcpdata();
  if (tcpdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tcpdata_ = new ::std::string;
  }
  tcpdata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TcpSegment.TcpSegment.TcpData)
}
inline ::std::string* TcpSegment::mutable_tcpdata() {
  set_has_tcpdata();
  if (tcpdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tcpdata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TcpSegment.TcpSegment.TcpData)
  return tcpdata_;
}
inline ::std::string* TcpSegment::release_tcpdata() {
  clear_has_tcpdata();
  if (tcpdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tcpdata_;
    tcpdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TcpSegment::set_allocated_tcpdata(::std::string* tcpdata) {
  if (tcpdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tcpdata_;
  }
  if (tcpdata) {
    set_has_tcpdata();
    tcpdata_ = tcpdata;
  } else {
    clear_has_tcpdata();
    tcpdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TcpSegment.TcpSegment.TcpData)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace TcpSegment

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TcpSegment_2eproto__INCLUDED
